ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2C_I2C_INT.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2C_I2C_ISR,"ax",%progbits
  18              		.align	2
  19              		.global	I2C_I2C_ISR
  20              		.code	16
  21              		.thumb_func
  22              		.type	I2C_I2C_ISR, %function
  23              	I2C_I2C_ISR:
  24              	.LFB0:
  25              		.file 1 ".\\Generated_Source\\PSoC4\\I2C_I2C_INT.c"
   1:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * File Name: I2C_I2C_INT.c
   3:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Version 3.10
   4:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   5:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  the SCB Component in I2C mode.
   8:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   9:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Note:
  10:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  11:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** ********************************************************************************
  12:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Copyright 2013-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  14:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  15:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * the software package with which this file was provided.
  16:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
  17:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  18:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_PVT.h"
  19:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_I2C_PVT.h"
  20:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "cyapicallbacks.h"
  21:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  22:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  23:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** /*******************************************************************************
  24:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Function Name: I2C_I2C_ISR
  25:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** ********************************************************************************
  26:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  27:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Summary:
  28:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  Handles the Interrupt Service Routine for the SCB I2C mode.
  29:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  30:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Parameters:
  31:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  None
  32:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 2


  33:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** * Return:
  34:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *  None
  35:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  36:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
  37:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** CY_ISR(I2C_I2C_ISR)
  38:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** {
  26              		.loc 1 38 0
  27              		.cfi_startproc
  28 0000 10B5     		push	{r4, lr}
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 4, -8
  31              		.cfi_offset 14, -4
  32              	.LVL0:
  39:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 diffCount;
  40:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 endTransfer;
  41:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  42:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_ENTRY_CALLBACK
  43:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_EntryCallback();
  44:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_ENTRY_CALLBACK */
  45:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     
  46:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
  47:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 response;
  48:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  49:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     response = I2C_I2C_ACK_ADDR;
  50:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
  51:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  53:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  54:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Calls customer routine if registered */
  55:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(NULL != I2C_customIntrHandler)
  33              		.loc 1 55 0
  34 0002 C04B     		ldr	r3, .L41
  35 0004 1B68     		ldr	r3, [r3]
  36 0006 002B     		cmp	r3, #0
  37 0008 00D0     		beq	.L2
  56:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  57:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_customIntrHandler();
  38              		.loc 1 57 0
  39 000a 9847     		blx	r3
  40              	.LVL1:
  41              	.L2:
  58:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  59:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  60:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_INTR_I2C_EC_MASKED(I2C_INTR_I2C_EC_WAKE_UP))
  42              		.loc 1 60 0
  43 000c BE4B     		ldr	r3, .L41+4
  44 000e 1B68     		ldr	r3, [r3]
  45 0010 DB07     		lsl	r3, r3, #31
  46 0012 02D5     		bpl	.L3
  61:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  62:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Mask-off after wakeup */
  63:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetI2CExtClkInterruptMode(I2C_NO_INTR_SOURCES);
  47              		.loc 1 63 0
  48 0014 0022     		mov	r2, #0
  49 0016 BD4B     		ldr	r3, .L41+8
  50 0018 1A60     		str	r2, [r3]
  51              	.L3:
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 3


  64:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  65:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  66:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Master and Slave error tracking:
  67:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Add the master state check to track only the master errors when the master is active or
  68:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * track slave errors when the slave is active or idle.
  69:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * A special MMS case: in the address phase with misplaced Start: the master sets the LOST_ARB a
  70:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * slave BUS_ERR. The valid event is LOST_ARB comes from the master.
  71:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
  72:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
  52              		.loc 1 72 0
  53 001a BD4B     		ldr	r3, .L41+12
  54 001c 1B78     		ldrb	r3, [r3]
  55 001e 9B06     		lsl	r3, r3, #26
  56 0020 28D5     		bpl	.L32
  73:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  74:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
  75:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
  76:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_BUS_ERROR:
  77:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A misplaced Start or Stop condition occurred on the bus: complete the transaction.
  78:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt is cleared in I2C_FSM_EXIT_IDLE.
  79:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
  80:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_BUS_ERROR))
  57              		.loc 1 80 0
  58 0022 BC4B     		ldr	r3, .L41+16
  59 0024 1B68     		ldr	r3, [r3]
  60 0026 DB05     		lsl	r3, r3, #23
  61 0028 07D5     		bpl	.L33
  81:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  82:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  62              		.loc 1 82 0
  63 002a BB4A     		ldr	r2, .L41+20
  64 002c 1188     		ldrh	r1, [r2]
  65 002e C023     		mov	r3, #192
  66 0030 9B00     		lsl	r3, r3, #2
  67 0032 0B43     		orr	r3, r1
  68 0034 1380     		strh	r3, [r2]
  69              	.LVL2:
  83:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_BUS_ERROR);
  84:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  85:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  70              		.loc 1 85 0
  71 0036 0123     		mov	r3, #1
  72 0038 00E0     		b	.L5
  73              	.LVL3:
  74              	.L33:
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  75              		.loc 1 52 0
  76 003a 0023     		mov	r3, #0
  77              	.LVL4:
  78              	.L5:
  86:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
  87:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  88:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_ARB_LOST:
  89:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The MultiMaster lost arbitrage during transaction.
  90:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition is treated as lost arbitration when the master dr
  91:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt source is cleared in I2C_FSM_EXIT_IDLE.
  92:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 4


  93:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
  79              		.loc 1 93 0
  80 003c B54A     		ldr	r2, .L41+16
  81 003e 1268     		ldr	r2, [r2]
  82 0040 D207     		lsl	r2, r2, #31
  83 0042 06D5     		bpl	.L6
  94:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  95:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  84              		.loc 1 95 0
  85 0044 B44A     		ldr	r2, .L41+20
  86 0046 1188     		ldrh	r1, [r2]
  87 0048 9023     		mov	r3, #144
  88              	.LVL5:
  89 004a 9B00     		lsl	r3, r3, #2
  90 004c 0B43     		orr	r3, r1
  91 004e 1380     		strh	r3, [r2]
  92              	.LVL6:
  96:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_ARB_LOST);
  97:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  98:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  93              		.loc 1 98 0
  94 0050 0123     		mov	r3, #1
  95              	.LVL7:
  96              	.L6:
  99:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 100:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 101:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if(I2C_I2C_MULTI_MASTER_SLAVE)
 102:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 103:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* I2C_MASTER_CMD_M_START_ON_IDLE:
 104:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * MultiMaster-Slave does not generate start, because Slave was addressed.
 105:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * Pass control to slave.
 106:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 107:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
 108:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 109:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 110:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                              I2C_I2C_MSTAT_ERR_ABORT_XFER);
 111:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 112:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 113:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 114:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 115:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif
 116:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 117:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* The error handling common part:
 118:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Sets a completion flag of the master transaction and passes control to:
 119:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_EXIT_IDLE - to complete transaction in case of: ARB_LOST or BUS_ERR.
 120:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_IDLE      - to take chance for the slave to process incoming transaction.
 121:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 122:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(0u != endTransfer)
  97              		.loc 1 122 0
  98 0052 002B     		cmp	r3, #0
  99 0054 0FD0     		beq	.L4
 123:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 124:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Set completion flags for master */
 125:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 100              		.loc 1 125 0
 101 0056 AE4A     		ldr	r2, .L41+12
 102 0058 1278     		ldrb	r2, [r2]
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 5


 103 005a D207     		lsl	r2, r2, #31
 104 005c 01D5     		bpl	.L34
 105 005e 0122     		mov	r2, #1
 106 0060 00E0     		b	.L7
 107              	.L34:
 108 0062 0222     		mov	r2, #2
 109              	.L7:
 110              		.loc 1 125 0 is_stmt 0 discriminator 4
 111 0064 AC49     		ldr	r1, .L41+20
 112 0066 0888     		ldrh	r0, [r1]
 113 0068 0243     		orr	r2, r0
 114 006a 0A80     		strh	r2, [r1]
 126:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 127:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if(I2C_I2C_MULTI_MASTER_SLAVE)
 128:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 129:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_ADDR)
 130:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 131:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start generation is set after another master starts accessing Slave.
 132:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Clean-up master and turn to slave. Set state to IDLE.
 133:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 134:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
 135:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 136:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_I2C_MASTER_CLEAR_START;
 137:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 138:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 139:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 140:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Valid arbitration lost on the address phase happens only when: master LO
 141:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * slave BUS_ERR is cleared. Only in that case set the state to IDLE without
 142:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 143:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if((!I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR))
 144:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                && I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
 145:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 146:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 147:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 148:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 149:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 150:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = 0u; /* Causes I2C_FSM_EXIT_IDLE to be set below */
 151:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 152:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 153:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(0u != endTransfer) /* Clean-up master to proceed with slave */
 154:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 155:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO; /* Shifter keeps address, clear it */
 156:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 157:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_DISABLE_MASTER_AUTO_DATA_ACK; /* In case of reading disable autoACK
 158:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 159:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Clean-up master interrupt sources */
 160:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 161:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 162:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Disable data processing interrupts: they have to be cleared before *
 163:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 164:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 165:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 166:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_IDLE;
 167:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 168:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 169:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 170:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Set I2C_FSM_EXIT_IDLE for BUS_ERR and ARB_LOST (that is really bus e
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 6


 171:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 172:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 173:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 174:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 175:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 176:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set I2C_FSM_EXIT_IDLE if any other state than address */
 177:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 178:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 179:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 180:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #else
 181:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 182:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* In case of LOST*/
 183:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 115              		.loc 1 183 0 is_stmt 1 discriminator 4
 116 006c 0021     		mov	r1, #0
 117 006e A84A     		ldr	r2, .L41+12
 118 0070 1170     		strb	r1, [r2]
 119 0072 00E0     		b	.L4
 120              	.LVL8:
 121              	.L32:
  52:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 122              		.loc 1 52 0
 123 0074 0023     		mov	r3, #0
 124              	.LVL9:
 125              	.L4:
 184:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 185:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 186:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 187:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 188:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 189:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 190:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else /* (I2C_CHECK_I2C_FSM_SLAVE) */
 191:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 192:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 193:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 194:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_BUS_ERROR or I2C_INTR_SLAVE_I2C_ARB_LOST:
 195:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition occurred on the bus: set a flag
 196:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * to notify an error condition.
 197:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 198:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR |
 199:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                         I2C_INTR_SLAVE_I2C_ARB_LOST))
 200:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 201:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_RD)
 202:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 203:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 204:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
 205:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_RD_ERR |
 206:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_RD_CMPLT);
 207:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 208:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 209:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 210:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 211:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
 212:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_WR_ERR |
 213:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_WR_CMPLT);
 214:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 215:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 7


 216:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 217:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 218:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 219:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 220:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 221:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 222:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* States description:
 223:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Master operation starts from: the ADDR_RD/WR state as the master generates traffic on the
 224:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Slave operation starts from: the IDLE state as the slave always waits for actions from th
 225:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 226:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 227:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Master */
 228:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
 126              		.loc 1 228 0
 127 0076 A64A     		ldr	r2, .L41+12
 128 0078 1278     		ldrb	r2, [r2]
 129 007a 9206     		lsl	r2, r2, #26
 130 007c 00D4     		bmi	.LCB127
 131 007e 14E1     		b	.L8	@long jump
 132              	.LCB127:
 229:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 230:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
 231:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 232:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_STOP:
 233:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Stop condition was generated by the master: the end of the transaction.
 234:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Set completion flags to notify the API.
 235:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 236:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_STOP))
 133              		.loc 1 236 0
 134 0080 A44A     		ldr	r2, .L41+16
 135 0082 1268     		ldr	r2, [r2]
 136 0084 D206     		lsl	r2, r2, #27
 137 0086 11D5     		bpl	.L9
 237:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 238:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_STOP);
 138              		.loc 1 238 0
 139 0088 1022     		mov	r2, #16
 140 008a A44B     		ldr	r3, .L41+24
 141              	.LVL10:
 142 008c 1A60     		str	r2, [r3]
 239:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 240:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 143              		.loc 1 240 0
 144 008e A04B     		ldr	r3, .L41+12
 145 0090 1B78     		ldrb	r3, [r3]
 146 0092 DB07     		lsl	r3, r3, #31
 147 0094 01D5     		bpl	.L35
 148 0096 0123     		mov	r3, #1
 149 0098 00E0     		b	.L10
 150              	.L35:
 151 009a 0223     		mov	r3, #2
 152              	.L10:
 153              		.loc 1 240 0 is_stmt 0 discriminator 4
 154 009c 9E4A     		ldr	r2, .L41+20
 155 009e 1188     		ldrh	r1, [r2]
 156 00a0 0B43     		orr	r3, r1
 157 00a2 1380     		strh	r3, [r2]
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 8


 241:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state       = I2C_I2C_FSM_IDLE;
 158              		.loc 1 241 0 is_stmt 1 discriminator 4
 159 00a4 1022     		mov	r2, #16
 160 00a6 9A4B     		ldr	r3, .L41+12
 161 00a8 1A70     		strb	r2, [r3]
 162 00aa 29E1     		b	.L1
 163              	.LVL11:
 164              	.L9:
 242:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 243:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 244:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 245:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_ADDR) /* Address stage */
 165              		.loc 1 245 0
 166 00ac 984A     		ldr	r2, .L41+12
 167 00ae 1278     		ldrb	r2, [r2]
 168 00b0 1207     		lsl	r2, r2, #28
 169 00b2 20D5     		bpl	.L12
 246:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 247:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_MASTER_I2C_NACK:
 248:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * The master sent an address but it was NACKed by the slave. Complete transacti
 249:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 250:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 170              		.loc 1 250 0
 171 00b4 974A     		ldr	r2, .L41+16
 172 00b6 1268     		ldr	r2, [r2]
 173 00b8 9207     		lsl	r2, r2, #30
 174 00ba 0AD5     		bpl	.L13
 251:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 252:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 175              		.loc 1 252 0
 176 00bc 0222     		mov	r2, #2
 177 00be 974B     		ldr	r3, .L41+24
 178              	.LVL12:
 179 00c0 1A60     		str	r2, [r3]
 253:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 254:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 180              		.loc 1 254 0
 181 00c2 954A     		ldr	r2, .L41+20
 182 00c4 1188     		ldrh	r1, [r2]
 183 00c6 8823     		mov	r3, #136
 184 00c8 9B00     		lsl	r3, r3, #2
 185 00ca 0B43     		orr	r3, r1
 186 00cc 1380     		strh	r3, [r2]
 187              	.LVL13:
 255:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_I2C_MSTAT_ERR_ADDR_NAK);
 256:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 257:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 188              		.loc 1 257 0
 189 00ce 0123     		mov	r3, #1
 190 00d0 11E0     		b	.L12
 191              	.LVL14:
 192              	.L13:
 258:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 259:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_TX_UNDERFLOW. The master sent an address:
 260:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - TX direction: the clock is stretched after the ACK phase, because the TX F
 261:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    EMPTY. The TX EMPTY cleans all the TX interrupt sources.
 262:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - RX direction: the 1st byte is received, but there is no ACK permission,
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 9


 263:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    the clock is stretched after 1 byte is received.
 264:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 265:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 266:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 267:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 193              		.loc 1 267 0
 194 00d2 8F4A     		ldr	r2, .L41+12
 195 00d4 1278     		ldrb	r2, [r2]
 196 00d6 D207     		lsl	r2, r2, #31
 197 00d8 03D5     		bpl	.L14
 268:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 269:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_RD_DATA;
 198              		.loc 1 269 0
 199 00da 2521     		mov	r1, #37
 200 00dc 8C4A     		ldr	r2, .L41+12
 201 00de 1170     		strb	r1, [r2]
 202 00e0 09E0     		b	.L12
 203              	.L14:
 270:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 271:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else /* Writing */
 272:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 273:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_WR_DATA;
 204              		.loc 1 273 0
 205 00e2 2421     		mov	r1, #36
 206 00e4 8A4A     		ldr	r2, .L41+12
 207 00e6 1170     		strb	r1, [r2]
 274:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(0u != I2C_mstrWrBufSize)
 208              		.loc 1 274 0
 209 00e8 8D4A     		ldr	r2, .L41+28
 210 00ea 1268     		ldr	r2, [r2]
 211 00ec 002A     		cmp	r2, #0
 212 00ee 02D0     		beq	.L12
 275:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 276:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Enable INTR.TX_EMPTY if there is data to transmit */
 277:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 213              		.loc 1 277 0
 214 00f0 1439     		sub	r1, r1, #20
 215 00f2 8C4A     		ldr	r2, .L41+32
 216 00f4 1160     		str	r1, [r2]
 217              	.LVL15:
 218              	.L12:
 278:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 279:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 280:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 281:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 282:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 283:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_DATA) /* Data phase */
 219              		.loc 1 283 0
 220 00f6 864A     		ldr	r2, .L41+12
 221 00f8 1278     		ldrb	r2, [r2]
 222 00fa 5207     		lsl	r2, r2, #29
 223 00fc 00D4     		bmi	.LCB237
 224 00fe ABE0     		b	.L15	@long jump
 225              	.LCB237:
 284:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 285:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 226              		.loc 1 285 0
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 10


 227 0100 834A     		ldr	r2, .L41+12
 228 0102 1278     		ldrb	r2, [r2]
 229 0104 D207     		lsl	r2, r2, #31
 230 0106 49D5     		bpl	.L16
 286:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 287:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_FULL:
 288:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received 8 bytes.
 289:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Get data from RX FIFO and decide whether to ACK or  NACK the following by
 290:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 291:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
 231              		.loc 1 291 0
 232 0108 874A     		ldr	r2, .L41+36
 233 010a 1268     		ldr	r2, [r2]
 234 010c 1207     		lsl	r2, r2, #28
 235 010e 27D5     		bpl	.L17
 292:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 293:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Calculate difference */
 294:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             diffCount =  I2C_mstrRdBufSize -
 236              		.loc 1 294 0
 237 0110 864A     		ldr	r2, .L41+40
 238 0112 1268     		ldr	r2, [r2]
 295:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 239              		.loc 1 295 0
 240 0114 8649     		ldr	r1, .L41+44
 241 0116 0968     		ldr	r1, [r1]
 242 0118 0F24     		mov	r4, #15
 243 011a 0C40     		and	r4, r1
 244 011c 8549     		ldr	r1, .L41+48
 245 011e 0968     		ldr	r1, [r1]
 246 0120 6418     		add	r4, r4, r1
 294:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 247              		.loc 1 294 0
 248 0122 141B     		sub	r4, r2, r4
 249              	.LVL16:
 296:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 297:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Proceed transaction or end it when RX FIFO becomes FULL again */
 298:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount > I2C_I2C_FIFO_SIZE)
 250              		.loc 1 298 0
 251 0124 082C     		cmp	r4, #8
 252 0126 09D8     		bhi	.L36
 299:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 300:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 diffCount = I2C_I2C_FIFO_SIZE;
 301:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 302:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 303:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 304:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(0u == diffCount)
 253              		.loc 1 304 0
 254 0128 002C     		cmp	r4, #0
 255 012a 16D1     		bne	.L19
 305:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 306:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 256              		.loc 1 306 0
 257 012c 824A     		ldr	r2, .L41+52
 258 012e 1168     		ldr	r1, [r2]
 259 0130 824B     		ldr	r3, .L41+56
 260              	.LVL17:
 261 0132 0B40     		and	r3, r1
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 11


 262 0134 1360     		str	r3, [r2]
 263              	.LVL18:
 307:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 308:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     diffCount   = I2C_I2C_FIFO_SIZE;
 309:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 264              		.loc 1 309 0
 265 0136 0123     		mov	r3, #1
 308:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 266              		.loc 1 308 0
 267 0138 0834     		add	r4, r4, #8
 268 013a 0EE0     		b	.L19
 269              	.LVL19:
 270              	.L36:
 300:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 271              		.loc 1 300 0
 272 013c 0824     		mov	r4, #8
 273              	.LVL20:
 274 013e 0CE0     		b	.L19
 275              	.LVL21:
 276              	.L20:
 310:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 311:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 312:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 314:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 315:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8)
 277              		.loc 1 315 0 discriminator 2
 278 0140 7C4A     		ldr	r2, .L41+48
 279 0142 1168     		ldr	r1, [r2]
 280 0144 7E48     		ldr	r0, .L41+60
 281 0146 0068     		ldr	r0, [r0]
 282 0148 4118     		add	r1, r0, r1
 316:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                                         I2C_RX_FIFO
 283              		.loc 1 316 0 discriminator 2
 284 014a 7E48     		ldr	r0, .L41+64
 285 014c 0068     		ldr	r0, [r0]
 315:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                                         I2C_RX_FIFO
 286              		.loc 1 315 0 discriminator 2
 287 014e C0B2     		uxtb	r0, r0
 288 0150 0870     		strb	r0, [r1]
 317:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufIndex++;
 289              		.loc 1 317 0 discriminator 2
 290 0152 1168     		ldr	r1, [r2]
 291 0154 0131     		add	r1, r1, #1
 292 0156 1160     		str	r1, [r2]
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 293              		.loc 1 313 0 discriminator 2
 294 0158 013C     		sub	r4, r4, #1
 295              	.LVL22:
 296              	.L19:
 313:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 297              		.loc 1 313 0 is_stmt 0 discriminator 1
 298 015a 002C     		cmp	r4, #0
 299 015c F0D1     		bne	.L20
 300 015e 19E0     		b	.L21
 301              	.LVL23:
 302              	.L17:
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 12


 318:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 319:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 320:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_NOT_EMPTY:
 321:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received one data byte, ACK or NACK it.
 322:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The last byte is stored and NACKed by the master. The NACK and Stop is
 323:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * generated by one command generate Stop.
 324:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 325:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 303              		.loc 1 325 0 is_stmt 1
 304 0160 714A     		ldr	r2, .L41+36
 305 0162 1268     		ldr	r2, [r2]
 306 0164 5207     		lsl	r2, r2, #29
 307 0166 15D5     		bpl	.L21
 326:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 327:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Put data in component buffer */
 328:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 308              		.loc 1 328 0
 309 0168 724A     		ldr	r2, .L41+48
 310 016a 1168     		ldr	r1, [r2]
 311 016c 7448     		ldr	r0, .L41+60
 312 016e 0068     		ldr	r0, [r0]
 313 0170 4118     		add	r1, r0, r1
 314 0172 7448     		ldr	r0, .L41+64
 315 0174 0068     		ldr	r0, [r0]
 316 0176 C0B2     		uxtb	r0, r0
 317 0178 0870     		strb	r0, [r1]
 329:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufIndex++;
 318              		.loc 1 329 0
 319 017a 1168     		ldr	r1, [r2]
 320 017c 0131     		add	r1, r1, #1
 321 017e 1160     		str	r1, [r2]
 330:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 331:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrRdBufIndex < I2C_mstrRdBufSize)
 322              		.loc 1 331 0
 323 0180 1168     		ldr	r1, [r2]
 324 0182 6A4A     		ldr	r2, .L41+40
 325 0184 1268     		ldr	r2, [r2]
 326 0186 9142     		cmp	r1, r2
 327 0188 03D2     		bcs	.L37
 332:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 333:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_I2C_MASTER_GENERATE_ACK;
 328              		.loc 1 333 0
 329 018a 0421     		mov	r1, #4
 330 018c 6E4A     		ldr	r2, .L41+68
 331 018e 1160     		str	r1, [r2]
 332 0190 00E0     		b	.L21
 333              	.L37:
 334:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 335:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 336:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 337:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 334              		.loc 1 337 0
 335 0192 0123     		mov	r3, #1
 336              	.LVL24:
 337              	.L21:
 338:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 339:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 13


 340:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 341:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 342:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 343:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 344:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 345:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 338              		.loc 1 345 0
 339 0194 6D49     		ldr	r1, .L41+72
 340 0196 6E4A     		ldr	r2, .L41+76
 341 0198 1160     		str	r1, [r2]
 342 019a 5DE0     		b	.L15
 343              	.L16:
 346:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 347:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else /* Writing */
 348:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 349:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_MASTER_I2C_NACK :
 350:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The master writes data to the slave and NACK was received: not all the by
 351:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * written to the slave from the TX FIFO. Revert the index if there is data 
 352:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the TX FIFO and pass control to a complete transfer.
 353:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 354:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 344              		.loc 1 354 0
 345 019c 5D4A     		ldr	r2, .L41+16
 346 019e 1268     		ldr	r2, [r2]
 347 01a0 9207     		lsl	r2, r2, #30
 348 01a2 26D5     		bpl	.L22
 355:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 356:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 349              		.loc 1 356 0
 350 01a4 0222     		mov	r2, #2
 351 01a6 5D4B     		ldr	r3, .L41+24
 352              	.LVL25:
 353 01a8 1A60     		str	r2, [r3]
 357:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 358:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Rollback write buffer index: NACKed byte remains in shifter */
 359:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndexTmp -= (I2C_GET_TX_FIFO_ENTRIES +
 354              		.loc 1 359 0
 355 01aa 6A4A     		ldr	r2, .L41+80
 356 01ac 1368     		ldr	r3, [r2]
 357 01ae 0F21     		mov	r1, #15
 358 01b0 1940     		and	r1, r3
 360:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 359              		.loc 1 360 0
 360 01b2 1368     		ldr	r3, [r2]
 361 01b4 8022     		mov	r2, #128
 362 01b6 1202     		lsl	r2, r2, #8
 363 01b8 1340     		and	r3, r2
 359:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 364              		.loc 1 359 0
 365 01ba 00D0     		beq	.L23
 366 01bc 0123     		mov	r3, #1
 367              	.L23:
 359:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 368              		.loc 1 359 0 is_stmt 0 discriminator 4
 369 01be CB18     		add	r3, r1, r3
 370 01c0 654A     		ldr	r2, .L41+84
 371 01c2 1168     		ldr	r1, [r2]
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 14


 372 01c4 CB1A     		sub	r3, r1, r3
 373 01c6 1360     		str	r3, [r2]
 361:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 362:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 363:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 374              		.loc 1 363 0 is_stmt 1 discriminator 4
 375 01c8 1268     		ldr	r2, [r2]
 376 01ca 644B     		ldr	r3, .L41+88
 377 01cc 1A60     		str	r2, [r3]
 364:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 365:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 378              		.loc 1 365 0 discriminator 4
 379 01ce 524A     		ldr	r2, .L41+20
 380 01d0 1188     		ldrh	r1, [r2]
 381 01d2 8423     		mov	r3, #132
 382 01d4 9B00     		lsl	r3, r3, #2
 383 01d6 0B43     		orr	r3, r1
 384 01d8 1380     		strh	r3, [r2]
 366:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                      I2C_I2C_MSTAT_ERR_SHORT_XFER);
 367:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 368:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO;
 385              		.loc 1 368 0 discriminator 4
 386 01da 614B     		ldr	r3, .L41+92
 387 01dc 1A68     		ldr	r2, [r3]
 388 01de 8021     		mov	r1, #128
 389 01e0 4902     		lsl	r1, r1, #9
 390 01e2 0A43     		orr	r2, r1
 391 01e4 1A60     		str	r2, [r3]
 392 01e6 1968     		ldr	r1, [r3]
 393 01e8 5E4A     		ldr	r2, .L41+96
 394 01ea 0A40     		and	r2, r1
 395 01ec 1A60     		str	r2, [r3]
 396              	.LVL26:
 369:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 370:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 397              		.loc 1 370 0 discriminator 4
 398 01ee 0123     		mov	r3, #1
 399 01f0 32E0     		b	.L15
 400              	.LVL27:
 401              	.L22:
 371:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 372:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_EMPTY :
 373:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: the TX FIFO is EMPTY, the data from the buffer needs to be 
 374:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * When there is no data in the component buffer, the underflow interrupt is
 375:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * enabled to catch when all the data has been transferred.
 376:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 377:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
 402              		.loc 1 377 0
 403 01f2 5D4A     		ldr	r2, .L41+100
 404 01f4 1268     		ldr	r2, [r2]
 405 01f6 D206     		lsl	r2, r2, #27
 406 01f8 12D4     		bmi	.L24
 407 01fa 24E0     		b	.L40
 408              	.L27:
 378:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 379:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 380:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 15


 381:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* The temporary mstrWrBufIndexTmp is used because slave could NACK
 382:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 * roll-back required in this case. The mstrWrBufIndex is updated at
 383:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 */
 384:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(I2C_mstrWrBufIndexTmp < I2C_mstrWrBufSize)
 409              		.loc 1 384 0
 410 01fc 564A     		ldr	r2, .L41+84
 411 01fe 1168     		ldr	r1, [r2]
 412 0200 474A     		ldr	r2, .L41+28
 413 0202 1268     		ldr	r2, [r2]
 414 0204 9142     		cmp	r1, r2
 415 0206 11D2     		bcs	.L26
 385:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 386:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 #if(!I2C_CY_SCBIP_V0)
 387:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                    /* Clear INTR_TX.UNDERFLOW before putting the last byte into TX 
 388:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * a proper trigger at the end of transaction when INTR_TX.UNDER
 389:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * event. Ticket ID# 156735.
 390:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     */
 391:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     if(I2C_mstrWrBufIndexTmp == (I2C_mstrWrBufSize - 1u))
 392:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     {
 393:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_ClearTxInterruptSource(I2C_INTR_TX_UNDERFLOW);
 394:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 395:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     }
 396:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                  #endif /* (!I2C_CY_SCBIP_V0) */
 397:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 398:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Put data into TX FIFO */
 399:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_TX_FIFO_WR_REG = (uint32) I2C_mstrWrBufPtr[I2C_mstrWrBufInd
 416              		.loc 1 399 0
 417 0208 534A     		ldr	r2, .L41+84
 418 020a 1168     		ldr	r1, [r2]
 419 020c 5748     		ldr	r0, .L41+104
 420 020e 0068     		ldr	r0, [r0]
 421 0210 4118     		add	r1, r0, r1
 422 0212 0978     		ldrb	r1, [r1]
 423 0214 C9B2     		uxtb	r1, r1
 424 0216 5648     		ldr	r0, .L41+108
 425 0218 0160     		str	r1, [r0]
 400:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_mstrWrBufIndexTmp++;
 426              		.loc 1 400 0
 427 021a 1168     		ldr	r1, [r2]
 428 021c 0131     		add	r1, r1, #1
 429 021e 1160     		str	r1, [r2]
 430              	.L24:
 379:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 431              		.loc 1 379 0
 432 0220 4C4A     		ldr	r2, .L41+80
 433 0222 1268     		ldr	r2, [r2]
 434 0224 0F21     		mov	r1, #15
 435 0226 0A40     		and	r2, r1
 436 0228 082A     		cmp	r2, #8
 437 022a E7D1     		bne	.L27
 438              	.L26:
 401:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 402:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 403:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 404:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     break; /* No more data to put */
 405:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 406:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 16


 407:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 408:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CY_SCBIP_V0)
 409:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrWrBufIndexTmp == I2C_mstrWrBufSize)
 439              		.loc 1 409 0
 440 022c 4A4A     		ldr	r2, .L41+84
 441 022e 1168     		ldr	r1, [r2]
 442 0230 3B4A     		ldr	r2, .L41+28
 443 0232 1268     		ldr	r2, [r2]
 444 0234 9142     		cmp	r1, r2
 445 0236 02D1     		bne	.L28
 410:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 411:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 446              		.loc 1 411 0
 447 0238 4021     		mov	r1, #64
 448 023a 3A4A     		ldr	r2, .L41+32
 449 023c 1160     		str	r1, [r2]
 450              	.L28:
 412:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 413:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 414:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_ALL);
 451              		.loc 1 414 0
 452 023e 4D49     		ldr	r1, .L41+112
 453 0240 4D4A     		ldr	r2, .L41+116
 454 0242 1160     		str	r1, [r2]
 455 0244 08E0     		b	.L15
 456              	.L40:
 415:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 416:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 417:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif /* (I2C_CY_SCBIP_V0) */
 418:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 419:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_UNDERFLOW:
 420:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: all data from the TX FIFO was transferred to the slave.
 421:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The transaction needs to be completed.
 422:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 423:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_UNDERFLOW))
 457              		.loc 1 423 0
 458 0246 484A     		ldr	r2, .L41+100
 459 0248 1268     		ldr	r2, [r2]
 460 024a 5206     		lsl	r2, r2, #25
 461 024c 04D5     		bpl	.L15
 424:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 425:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 426:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 462              		.loc 1 426 0
 463 024e 424B     		ldr	r3, .L41+84
 464              	.LVL28:
 465 0250 1A68     		ldr	r2, [r3]
 466 0252 424B     		ldr	r3, .L41+88
 467 0254 1A60     		str	r2, [r3]
 468              	.LVL29:
 427:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 428:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 469              		.loc 1 428 0
 470 0256 0123     		mov	r3, #1
 471              	.LVL30:
 472              	.L15:
 429:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 17


 430:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 431:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 432:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 433:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 434:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 435:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 436:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 437:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* Complete transfer */
 473              		.loc 1 437 0
 474 0258 002B     		cmp	r3, #0
 475 025a 51D0     		beq	.L1
 438:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 439:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clean-up master after reading: only in case of NACK */
 440:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 476              		.loc 1 440 0
 477 025c 364A     		ldr	r2, .L41+52
 478 025e 1168     		ldr	r1, [r2]
 479 0260 364B     		ldr	r3, .L41+56
 480              	.LVL31:
 481 0262 0B40     		and	r3, r1
 482 0264 1360     		str	r3, [r2]
 441:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 442:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable data processing interrupts: they have to be cleared before */
 443:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 483              		.loc 1 443 0
 484 0266 0023     		mov	r3, #0
 485 0268 444A     		ldr	r2, .L41+120
 486 026a 1360     		str	r3, [r2]
 444:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 487              		.loc 1 444 0
 488 026c 2D4A     		ldr	r2, .L41+32
 489 026e 1360     		str	r3, [r2]
 445:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 446:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_MODE_NO_STOP(I2C_mstrControl))
 490              		.loc 1 446 0
 491 0270 434B     		ldr	r3, .L41+124
 492 0272 1B78     		ldrb	r3, [r3]
 493 0274 9B07     		lsl	r3, r3, #30
 494 0276 0ED5     		bpl	.L29
 447:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 448:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* On-going transaction is suspended: the ReStart is generated by the API r
 449:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_XFER_HALT |
 450:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 495              		.loc 1 450 0
 496 0278 254B     		ldr	r3, .L41+12
 497 027a 1B78     		ldrb	r3, [r3]
 449:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 498              		.loc 1 449 0
 499 027c DB07     		lsl	r3, r3, #31
 500 027e 01D5     		bpl	.L38
 501 0280 0923     		mov	r3, #9
 502 0282 00E0     		b	.L30
 503              	.L38:
 504 0284 0A23     		mov	r3, #10
 505              	.L30:
 449:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 506              		.loc 1 449 0 is_stmt 0 discriminator 4
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 18


 507 0286 244A     		ldr	r2, .L41+20
 508 0288 1188     		ldrh	r1, [r2]
 509 028a 0B43     		orr	r3, r1
 510 028c 1380     		strh	r3, [r2]
 451:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 452:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_MSTR_HALT;
 511              		.loc 1 452 0 is_stmt 1 discriminator 4
 512 028e 6022     		mov	r2, #96
 513 0290 1F4B     		ldr	r3, .L41+12
 514 0292 1A70     		strb	r2, [r3]
 515 0294 34E0     		b	.L1
 516              	.L29:
 453:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 454:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 455:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 456:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Complete transaction: exclude the data processing state and generate Sto
 457:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The completion status will be set after Stop generation.
 458:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * A special case is read: because NACK and Stop are generated by the comman
 459:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Lost arbitration can occur during NACK generation when
 460:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the other master is still reading from the slave.
 461:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 462:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_I2C_MASTER_GENERATE_STOP;
 517              		.loc 1 462 0
 518 0296 3B4B     		ldr	r3, .L41+128
 519 0298 1B68     		ldr	r3, [r3]
 520 029a 9B06     		lsl	r3, r3, #26
 521 029c 01D5     		bpl	.L39
 522 029e 1822     		mov	r2, #24
 523 02a0 00E0     		b	.L31
 524              	.L39:
 525 02a2 1022     		mov	r2, #16
 526              	.L31:
 527              		.loc 1 462 0 is_stmt 0 discriminator 4
 528 02a4 284B     		ldr	r3, .L41+68
 529 02a6 1A60     		str	r2, [r3]
 530 02a8 2AE0     		b	.L1
 531              	.LVL32:
 532              	.L8:
 463:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 464:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 465:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 466:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 467:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         } /* (I2C_I2C_MASTER) */
 468:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 469:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 470:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     } /* (I2C_CHECK_I2C_FSM_MASTER) */
 471:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 472:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 473:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Slave */
 474:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else if(I2C_CHECK_I2C_FSM_SLAVE)
 533              		.loc 1 474 0 is_stmt 1
 534 02aa 194B     		ldr	r3, .L41+12
 535              	.LVL33:
 536 02ac 1B78     		ldrb	r3, [r3]
 537 02ae DB06     		lsl	r3, r3, #27
 538 02b0 26D4     		bmi	.L1
 475:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 19


 476:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 477:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 478:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_NACK:
 479:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes reading the slave: the appropriate flags have to be set.
 480:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The TX FIFO is cleared after an overflow condition is set.
 481:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 482:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_NACK))
 483:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 484:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_NACK);
 485:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 486:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* All entries that remain in TX FIFO max value is 9: 8 (FIFO) + 1 (SHIFTER) */
 487:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = (I2C_GET_TX_FIFO_ENTRIES + I2C_GET_TX_FIFO_SR_VALID);
 488:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 489:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slOverFlowCount > diffCount) /* Overflow */
 490:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 491:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_OVFL;
 492:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 493:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* No Overflow */
 494:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 495:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Roll-back temporary index */
 496:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slRdBufIndexTmp -= (diffCount - I2C_slOverFlowCount);
 497:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 498:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 499:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Update slave of transferred bytes */
 500:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slRdBufIndex = I2C_slRdBufIndexTmp;
 501:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 502:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clean-up TX FIFO */
 503:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 504:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slOverFlowCount = 0u;
 505:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_CLEAR_TX_FIFO;
 506:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 507:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master reading */
 508:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
 509:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_RD_CMPLT;
 510:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 511:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 512:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 513:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 514:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_WRITE_STOP:
 515:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes writing to the slave: the appropriate flags have to be set.
 516:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The RX FIFO contains 1-8 bytes from the previous transaction which needs to be read.
 517:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility that RX FIFO contains an address, it needs to leave it there.
 518:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 519:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_WRITE_STOP))
 520:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 521:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 522:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 523:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Read bytes from RX FIFO when auto data ACK receive logic is enabled. Otherwise a
 524:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * were already read from the RX FIFO except for address byte which has to stay here
 525:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * I2C_ADDR_MATCH.
 526:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 527:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (0u != (I2C_I2C_CTRL_REG & I2C_I2C_CTRL_S_READY_DATA_ACK))
 528:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 529:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     while(0u != I2C_GET_RX_FIFO_ENTRIES)
 530:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 531:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 532:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 20


 533:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if((1u == I2C_GET_RX_FIFO_ENTRIES) &&
 534:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH)))
 535:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 536:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 break; /* Leave address in RX FIFO */
 537:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 538:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 539:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 540:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 541:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Put data in component buffer */
 542:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 543:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufIndex++;
 544:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 545:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 546:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_SLAVE_AUTO_DATA;
 547:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 548:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 549:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_INTR_RX(I2C_INTR_RX_OVERFLOW))
 550:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 551:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 552:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 553:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 554:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clears RX interrupt sources triggered on data receiving */
 555:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 556:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 557:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 558:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master writing */
 559:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
 560:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_WR_CMPLT;
 561:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 562:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 563:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 564:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 565:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_ADDR_MATCH or INTR_SLAVE_I2C_GENERAL:
 566:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The address match or general call address event starts the slave operation:
 567:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * after leaving the TX or RX direction has to be chosen.
 568:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The wakeup interrupt must be cleared only after an address match is set.
 569:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 570:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 571:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH |
 572:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_INTR_SLAVE_I2C_GENERAL))
 573:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #else
 574:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH))
 575:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 576:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 577:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clear externally clocked address match interrupt source when internally clocked 
 578:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearI2CExtClkInterruptSource(I2C_INTR_I2C_EC_WAKE_UP);
 579:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 580:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER)
 581:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 582:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if (NULL != I2C_customAddressHandler)
 583:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 584:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Call custom address handler */
 585:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_customAddressHandler();
 586:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 587:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 588:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 589:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Read address from the RX FIFO. If there is no address underflow triggers
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 21


 590:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * componnet does not use that source. */
 591:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         (void) I2C_RX_FIFO_RD_REG;
 592:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_I2C_ACK_ADDR;
 593:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 594:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 595:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clears RX sources after address was received in the RX FIFO */
 596:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 597:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 598:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 599:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 600:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 601:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (response == I2C_I2C_NAK_ADDR)
 602:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 603:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 604:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable write stop interrupt source as it triggers after address was NACKed.
 605:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 606:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
 607:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 608:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 609:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 610:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 611:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 612:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
 613:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 614:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 615:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 616:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 617:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_STATUS(I2C_I2C_STATUS_S_READ))
 618:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 619:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 620:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 621:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 622:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set temporary index to address buffer clear from API */
 623:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp = I2C_slRdBufIndex;
 624:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 625:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 626:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_BUSY;
 627:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_RD;
 628:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 629:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 630:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 631:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 632:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Calculate available buffer size */
 633:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         diffCount = (I2C_slWrBufSize - I2C_slWrBufIndex);
 634:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 635:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #if (I2C_CY_SCBIP_V0)
 636:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(diffCount < I2C_I2C_FIFO_SIZE)
 637:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: byte-by-byte */
 638:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 639:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 640:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 641:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 642:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: into RX FIFO */
 643:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 644:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount == I2C_I2C_FIFO_SIZE)
 645:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 646:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* NACK when RX FIFO become FULL */
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 22


 647:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA;
 648:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 649:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 650:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 651:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Stretch clock when RX FIFO becomes FULL */
 652:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
 653:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 654:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 655:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 656:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 657:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #else
 658:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 659:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 660:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Enable RX.NOT_EMPTY interrupt source to receive byte by byte.
 661:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * The byte by byte receive is always chosen for the case when an addres
 662:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * in RX FIFO. Ticket ID#175559.
 663:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             */
 664:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 665:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 666:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 667:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 668:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount < I2C_I2C_FIFO_SIZE)
 669:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: byte-by-byte */
 670:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 671:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 672:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 673:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 674:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: into RX FIFO */
 675:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 676:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(diffCount == I2C_I2C_FIFO_SIZE)
 677:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 678:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* NACK when RX FIFO become FULL */
 679:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA;
 680:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 681:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 682:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 683:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Stretch clock when RX FIFO becomes FULL */
 684:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
 685:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 686:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 687:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 688:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 689:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 690:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #endif /* (I2C_CY_SCBIP_V0) */
 691:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 692:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 693:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_BUSY;
 694:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_WR;
 695:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 696:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 697:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 698:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 699:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 700:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 701:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Enable write stop interrupt source as it triggers after address was NACKed. 
 702:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 703:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 23


 704:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 705:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 706:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 707:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 708:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 709:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 710:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_FULL:
 711:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Get data from the RX FIFO and decide whether to ACK or NACK the following bytes
 712:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 713:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
 714:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 715:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Calculate available buffer size to take into account that RX FIFO is FULL */
 716:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount =  I2C_slWrBufSize -
 717:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             (I2C_slWrBufIndex + I2C_I2C_FIFO_SIZE);
 718:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 719:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(diffCount > I2C_I2C_FIFO_SIZE) /* Proceed transaction */
 720:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 721:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     diffCount   = I2C_I2C_FIFO_SIZE;
 722:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 723:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 724:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* End when FIFO becomes FULL again */
 725:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 726:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 727:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 728:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 729:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 for(; (0u != diffCount); diffCount--)
 730:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 731:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data in component buffer */
 732:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 733:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 734:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 735:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 736:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* End transfer sending NACK */
 737:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 738:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_SLAVE_AUTO_DATA_NACK;
 739:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 740:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_RX_FULL triggers earlier than INTR_SLAVE_I2C_STOP:
 741:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * disable all RX interrupt sources.
 742:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 743:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 744:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 745:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 746:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_FULL);
 747:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 748:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_NOT_EMPTY:
 749:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The buffer size is less than 8: it requires processing in byte-by-byte mode.
 750:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 751:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 752:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 753:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = I2C_RX_FIFO_RD_REG;
 754:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 755:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slWrBufIndex < I2C_slWrBufSize)
 756:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 757:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 758:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 759:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data into component buffer */
 760:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) diffCount;
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 24


 761:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 762:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 763:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* Overflow: there is no space in write buffer */
 764:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 765:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
 766:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 767:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 768:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 769:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 770:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_NOT_EMPTY);
 771:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 772:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 773:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 774:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Does nothing */
 775:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 776:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 777:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 778:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_TX_EMPTY:
 779:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master reads the slave: provide data to read or 0xFF in the case of the end of th
 780:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The overflow condition must be captured, but not set until the end of transaction.
 781:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility of a false overflow due to TX FIFO utilization.
 782:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 783:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
 784:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 785:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 786:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 787:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Temporary slRdBufIndexTmp is used because the master can NACK the byte and
 788:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * index roll-back is required in this case. The slRdBufIndex is updated at the 
 789:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * of the read transfer.
 790:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 791:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_slRdBufIndexTmp < I2C_slRdBufSize)
 792:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Data from buffer */
 793:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 794:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = (uint32) I2C_slRdBufPtr[I2C_slRdBufIndexTmp];
 795:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 796:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 797:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 798:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Probably Overflow */
 799:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 800:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = I2C_I2C_SLAVE_OVFL_RETURN;
 801:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 802:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(0u == (I2C_INTR_TX_OVERFLOW & I2C_slOverFlowCount))
 803:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 804:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Get counter in range of byte: value 10 is overflow */
 805:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_slOverFlowCount++;
 806:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 807:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 808:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 809:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 810:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 811:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 812:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 813:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         }  /* (I2C_I2C_SLAVE) */
 814:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 815:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 816:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 817:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 25


 818:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM EXIT:
 819:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Slave:  INTR_SLAVE_I2C_BUS_ERROR, INTR_SLAVE_I2C_ARB_LOST
 820:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Master: INTR_MASTER_I2C_BUS_ERROR, INTR_MASTER_I2C_ARB_LOST.
 821:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 822:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     else
 823:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 824:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG &= (uint32) ~I2C_CTRL_ENABLED; /* Disable scb IP */
 539              		.loc 1 824 0
 540 02b2 354A     		ldr	r2, .L41+132
 541 02b4 1368     		ldr	r3, [r2]
 542 02b6 5B00     		lsl	r3, r3, #1
 543 02b8 5B08     		lsr	r3, r3, #1
 544 02ba 1360     		str	r3, [r2]
 825:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 826:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_state = I2C_I2C_FSM_IDLE;
 545              		.loc 1 826 0
 546 02bc 1021     		mov	r1, #16
 547 02be 144B     		ldr	r3, .L41+12
 548 02c0 1970     		strb	r1, [r3]
 827:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 828:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_SLAVE_AUTO_DATA;
 549              		.loc 1 828 0
 550 02c2 1D4B     		ldr	r3, .L41+52
 551 02c4 1868     		ldr	r0, [r3]
 552 02c6 3149     		ldr	r1, .L41+136
 553 02c8 0140     		and	r1, r0
 554 02ca 1960     		str	r1, [r3]
 829:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_MASTER_AUTO_DATA;
 555              		.loc 1 829 0
 556 02cc 1868     		ldr	r0, [r3]
 557 02ce 3049     		ldr	r1, .L41+140
 558 02d0 0140     		and	r1, r0
 559 02d2 1960     		str	r1, [r3]
 830:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 831:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     #if(I2C_CY_SCBIP_V0)
 832:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 560              		.loc 1 832 0
 561 02d4 0023     		mov	r3, #0
 562 02d6 2949     		ldr	r1, .L41+120
 563 02d8 0B60     		str	r3, [r1]
 833:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 564              		.loc 1 833 0
 565 02da 1249     		ldr	r1, .L41+32
 566 02dc 0B60     		str	r3, [r1]
 834:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 835:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Clear interrupt sources as they are not automatically cleared after SCB is disabled */
 836:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearTxInterruptSource(I2C_INTR_RX_ALL);
 567              		.loc 1 836 0
 568 02de 1B49     		ldr	r1, .L41+72
 569 02e0 254B     		ldr	r3, .L41+116
 570 02e2 1960     		str	r1, [r3]
 837:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearRxInterruptSource(I2C_INTR_TX_ALL);
 571              		.loc 1 837 0
 572 02e4 2349     		ldr	r1, .L41+112
 573 02e6 1A4B     		ldr	r3, .L41+76
 574 02e8 1960     		str	r1, [r3]
 838:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 26


 575              		.loc 1 838 0
 576 02ea 2A49     		ldr	r1, .L41+144
 577 02ec 2A4B     		ldr	r3, .L41+148
 578 02ee 1960     		str	r1, [r3]
 839:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 579              		.loc 1 839 0
 580 02f0 2A49     		ldr	r1, .L41+152
 581 02f2 0A4B     		ldr	r3, .L41+24
 582 02f4 1960     		str	r1, [r3]
 840:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     #endif /* (I2C_CY_SCBIP_V0) */
 841:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 842:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG |= (uint32) I2C_CTRL_ENABLED;  /* Enable scb IP */
 583              		.loc 1 842 0
 584 02f6 1368     		ldr	r3, [r2]
 585 02f8 8021     		mov	r1, #128
 586 02fa 0906     		lsl	r1, r1, #24
 587 02fc 0B43     		orr	r3, r1
 588 02fe 1360     		str	r3, [r2]
 589              	.L1:
 843:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 844:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 845:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_EXIT_CALLBACK
 846:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_ExitCallback();
 847:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_EXIT_CALLBACK */
 848:.\Generated_Source\PSoC4/I2C_I2C_INT.c ****     
 849:.\Generated_Source\PSoC4/I2C_I2C_INT.c **** }
 590              		.loc 1 849 0
 591              		@ sp needed
 592 0300 10BD     		pop	{r4, pc}
 593              	.L42:
 594 0302 C046     		.align	2
 595              	.L41:
 596 0304 00000000 		.word	I2C_customIntrHandler
 597 0308 8C0E0740 		.word	1074204300
 598 030c 880E0740 		.word	1074204296
 599 0310 00000000 		.word	I2C_state
 600 0314 0C0F0740 		.word	1074204428
 601 0318 00000000 		.word	I2C_mstrStatus
 602 031c 000F0740 		.word	1074204416
 603 0320 00000000 		.word	I2C_mstrWrBufSize
 604 0324 880F0740 		.word	1074204552
 605 0328 CC0F0740 		.word	1074204620
 606 032c 00000000 		.word	I2C_mstrRdBufSize
 607 0330 08030740 		.word	1074201352
 608 0334 00000000 		.word	I2C_mstrRdBufIndex
 609 0338 60000740 		.word	1074200672
 610 033c FFFEFFFF 		.word	-257
 611 0340 00000000 		.word	I2C_mstrRdBufPtr
 612 0344 40030740 		.word	1074201408
 613 0348 68000740 		.word	1074200680
 614 034c ED0F0000 		.word	4077
 615 0350 C00F0740 		.word	1074204608
 616 0354 08020740 		.word	1074201096
 617 0358 00000000 		.word	I2C_mstrWrBufIndexTmp
 618 035c 00000000 		.word	I2C_mstrWrBufIndex
 619 0360 04020740 		.word	1074201092
 620 0364 FFFFFEFF 		.word	-65537
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 27


 621 0368 8C0F0740 		.word	1074204556
 622 036c 00000000 		.word	I2C_mstrWrBufPtr
 623 0370 40020740 		.word	1074201152
 624 0374 F3070000 		.word	2035
 625 0378 800F0740 		.word	1074204544
 626 037c C80F0740 		.word	1074204616
 627 0380 00000000 		.word	I2C_mstrControl
 628 0384 64000740 		.word	1074200676
 629 0388 00000740 		.word	1074200576
 630 038c FF5FFFFF 		.word	-40961
 631 0390 FFFCFFFF 		.word	-769
 632 0394 FF0F0000 		.word	4095
 633 0398 400F0740 		.word	1074204480
 634 039c 17030000 		.word	791
 635              		.cfi_endproc
 636              	.LFE0:
 637              		.size	I2C_I2C_ISR, .-I2C_I2C_ISR
 638              		.text
 639              	.Letext0:
 640              		.file 2 "Generated_Source\\PSoC4/cytypes.h"
 641              		.file 3 ".\\Generated_Source\\PSoC4\\I2C_PVT.h"
 642              		.file 4 ".\\Generated_Source\\PSoC4\\I2C_I2C_PVT.h"
 643              		.section	.debug_info,"",%progbits
 644              	.Ldebug_info0:
 645 0000 89010000 		.4byte	0x189
 646 0004 0400     		.2byte	0x4
 647 0006 00000000 		.4byte	.Ldebug_abbrev0
 648 000a 04       		.byte	0x4
 649 000b 01       		.uleb128 0x1
 650 000c 76010000 		.4byte	.LASF31
 651 0010 01       		.byte	0x1
 652 0011 7C020000 		.4byte	.LASF32
 653 0015 15010000 		.4byte	.LASF33
 654 0019 00000000 		.4byte	.Ldebug_ranges0+0
 655 001d 00000000 		.4byte	0
 656 0021 00000000 		.4byte	.Ldebug_line0
 657 0025 02       		.uleb128 0x2
 658 0026 01       		.byte	0x1
 659 0027 06       		.byte	0x6
 660 0028 65000000 		.4byte	.LASF0
 661 002c 02       		.uleb128 0x2
 662 002d 01       		.byte	0x1
 663 002e 08       		.byte	0x8
 664 002f 71000000 		.4byte	.LASF1
 665 0033 02       		.uleb128 0x2
 666 0034 02       		.byte	0x2
 667 0035 05       		.byte	0x5
 668 0036 04020000 		.4byte	.LASF2
 669 003a 02       		.uleb128 0x2
 670 003b 02       		.byte	0x2
 671 003c 07       		.byte	0x7
 672 003d 17000000 		.4byte	.LASF3
 673 0041 02       		.uleb128 0x2
 674 0042 04       		.byte	0x4
 675 0043 05       		.byte	0x5
 676 0044 44020000 		.4byte	.LASF4
 677 0048 02       		.uleb128 0x2
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 28


 678 0049 04       		.byte	0x4
 679 004a 07       		.byte	0x7
 680 004b 8F000000 		.4byte	.LASF5
 681 004f 02       		.uleb128 0x2
 682 0050 08       		.byte	0x8
 683 0051 05       		.byte	0x5
 684 0052 63010000 		.4byte	.LASF6
 685 0056 02       		.uleb128 0x2
 686 0057 08       		.byte	0x8
 687 0058 07       		.byte	0x7
 688 0059 F1000000 		.4byte	.LASF7
 689 005d 03       		.uleb128 0x3
 690 005e 04       		.byte	0x4
 691 005f 05       		.byte	0x5
 692 0060 696E7400 		.ascii	"int\000"
 693 0064 02       		.uleb128 0x2
 694 0065 04       		.byte	0x4
 695 0066 07       		.byte	0x7
 696 0067 E4000000 		.4byte	.LASF8
 697 006b 04       		.uleb128 0x4
 698 006c AB000000 		.4byte	.LASF9
 699 0070 02       		.byte	0x2
 700 0071 3801     		.2byte	0x138
 701 0073 2C000000 		.4byte	0x2c
 702 0077 04       		.uleb128 0x4
 703 0078 C4000000 		.4byte	.LASF10
 704 007c 02       		.byte	0x2
 705 007d 3901     		.2byte	0x139
 706 007f 3A000000 		.4byte	0x3a
 707 0083 04       		.uleb128 0x4
 708 0084 CB000000 		.4byte	.LASF11
 709 0088 02       		.byte	0x2
 710 0089 3A01     		.2byte	0x13a
 711 008b 48000000 		.4byte	0x48
 712 008f 02       		.uleb128 0x2
 713 0090 04       		.byte	0x4
 714 0091 04       		.byte	0x4
 715 0092 5F000000 		.4byte	.LASF12
 716 0096 02       		.uleb128 0x2
 717 0097 08       		.byte	0x8
 718 0098 04       		.byte	0x4
 719 0099 BD000000 		.4byte	.LASF13
 720 009d 02       		.uleb128 0x2
 721 009e 01       		.byte	0x1
 722 009f 08       		.byte	0x8
 723 00a0 71010000 		.4byte	.LASF14
 724 00a4 05       		.uleb128 0x5
 725 00a5 6B000000 		.4byte	0x6b
 726 00a9 05       		.uleb128 0x5
 727 00aa 77000000 		.4byte	0x77
 728 00ae 04       		.uleb128 0x4
 729 00af 00000000 		.4byte	.LASF15
 730 00b3 02       		.byte	0x2
 731 00b4 E401     		.2byte	0x1e4
 732 00b6 BA000000 		.4byte	0xba
 733 00ba 05       		.uleb128 0x5
 734 00bb 83000000 		.4byte	0x83
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 29


 735 00bf 04       		.uleb128 0x4
 736 00c0 08010000 		.4byte	.LASF16
 737 00c4 02       		.byte	0x2
 738 00c5 F401     		.2byte	0x1f4
 739 00c7 CB000000 		.4byte	0xcb
 740 00cb 06       		.uleb128 0x6
 741 00cc 04       		.byte	0x4
 742 00cd D1000000 		.4byte	0xd1
 743 00d1 07       		.uleb128 0x7
 744 00d2 02       		.uleb128 0x2
 745 00d3 04       		.byte	0x4
 746 00d4 07       		.byte	0x7
 747 00d5 5A010000 		.4byte	.LASF17
 748 00d9 08       		.uleb128 0x8
 749 00da B1000000 		.4byte	.LASF34
 750 00de 01       		.byte	0x1
 751 00df 25       		.byte	0x25
 752 00e0 00000000 		.4byte	.LFB0
 753 00e4 A0030000 		.4byte	.LFE0-.LFB0
 754 00e8 01       		.uleb128 0x1
 755 00e9 9C       		.byte	0x9c
 756 00ea 0D010000 		.4byte	0x10d
 757 00ee 09       		.uleb128 0x9
 758 00ef A1000000 		.4byte	.LASF18
 759 00f3 01       		.byte	0x1
 760 00f4 27       		.byte	0x27
 761 00f5 83000000 		.4byte	0x83
 762 00f9 00000000 		.4byte	.LLST0
 763 00fd 09       		.uleb128 0x9
 764 00fe 2A000000 		.4byte	.LASF19
 765 0102 01       		.byte	0x1
 766 0103 28       		.byte	0x28
 767 0104 83000000 		.4byte	0x83
 768 0108 35000000 		.4byte	.LLST1
 769 010c 00       		.byte	0
 770 010d 0A       		.uleb128 0xa
 771 010e 36000000 		.4byte	.LASF20
 772 0112 03       		.byte	0x3
 773 0113 3A       		.byte	0x3a
 774 0114 BF000000 		.4byte	0xbf
 775 0118 0A       		.uleb128 0xa
 776 0119 4D020000 		.4byte	.LASF21
 777 011d 04       		.byte	0x4
 778 011e 1D       		.byte	0x1d
 779 011f A4000000 		.4byte	0xa4
 780 0123 0A       		.uleb128 0xa
 781 0124 0E020000 		.4byte	.LASF22
 782 0128 04       		.byte	0x4
 783 0129 30       		.byte	0x30
 784 012a A9000000 		.4byte	0xa9
 785 012e 0A       		.uleb128 0xa
 786 012f 7F000000 		.4byte	.LASF23
 787 0133 04       		.byte	0x4
 788 0134 31       		.byte	0x31
 789 0135 A4000000 		.4byte	0xa4
 790 0139 0A       		.uleb128 0xa
 791 013a 1D020000 		.4byte	.LASF24
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 30


 792 013e 04       		.byte	0x4
 793 013f 34       		.byte	0x34
 794 0140 44010000 		.4byte	0x144
 795 0144 06       		.uleb128 0x6
 796 0145 04       		.byte	0x4
 797 0146 A4000000 		.4byte	0xa4
 798 014a 0A       		.uleb128 0xa
 799 014b D2000000 		.4byte	.LASF25
 800 014f 04       		.byte	0x4
 801 0150 35       		.byte	0x35
 802 0151 BA000000 		.4byte	0xba
 803 0155 0A       		.uleb128 0xa
 804 0156 4C000000 		.4byte	.LASF26
 805 015a 04       		.byte	0x4
 806 015b 36       		.byte	0x36
 807 015c BA000000 		.4byte	0xba
 808 0160 0A       		.uleb128 0xa
 809 0161 06000000 		.4byte	.LASF27
 810 0165 04       		.byte	0x4
 811 0166 39       		.byte	0x39
 812 0167 44010000 		.4byte	0x144
 813 016b 0A       		.uleb128 0xa
 814 016c 6A020000 		.4byte	.LASF28
 815 0170 04       		.byte	0x4
 816 0171 3A       		.byte	0x3a
 817 0172 BA000000 		.4byte	0xba
 818 0176 0A       		.uleb128 0xa
 819 0177 57020000 		.4byte	.LASF29
 820 017b 04       		.byte	0x4
 821 017c 3B       		.byte	0x3b
 822 017d BA000000 		.4byte	0xba
 823 0181 0A       		.uleb128 0xa
 824 0182 2E020000 		.4byte	.LASF30
 825 0186 04       		.byte	0x4
 826 0187 3C       		.byte	0x3c
 827 0188 BA000000 		.4byte	0xba
 828 018c 00       		.byte	0
 829              		.section	.debug_abbrev,"",%progbits
 830              	.Ldebug_abbrev0:
 831 0000 01       		.uleb128 0x1
 832 0001 11       		.uleb128 0x11
 833 0002 01       		.byte	0x1
 834 0003 25       		.uleb128 0x25
 835 0004 0E       		.uleb128 0xe
 836 0005 13       		.uleb128 0x13
 837 0006 0B       		.uleb128 0xb
 838 0007 03       		.uleb128 0x3
 839 0008 0E       		.uleb128 0xe
 840 0009 1B       		.uleb128 0x1b
 841 000a 0E       		.uleb128 0xe
 842 000b 55       		.uleb128 0x55
 843 000c 17       		.uleb128 0x17
 844 000d 11       		.uleb128 0x11
 845 000e 01       		.uleb128 0x1
 846 000f 10       		.uleb128 0x10
 847 0010 17       		.uleb128 0x17
 848 0011 00       		.byte	0
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 31


 849 0012 00       		.byte	0
 850 0013 02       		.uleb128 0x2
 851 0014 24       		.uleb128 0x24
 852 0015 00       		.byte	0
 853 0016 0B       		.uleb128 0xb
 854 0017 0B       		.uleb128 0xb
 855 0018 3E       		.uleb128 0x3e
 856 0019 0B       		.uleb128 0xb
 857 001a 03       		.uleb128 0x3
 858 001b 0E       		.uleb128 0xe
 859 001c 00       		.byte	0
 860 001d 00       		.byte	0
 861 001e 03       		.uleb128 0x3
 862 001f 24       		.uleb128 0x24
 863 0020 00       		.byte	0
 864 0021 0B       		.uleb128 0xb
 865 0022 0B       		.uleb128 0xb
 866 0023 3E       		.uleb128 0x3e
 867 0024 0B       		.uleb128 0xb
 868 0025 03       		.uleb128 0x3
 869 0026 08       		.uleb128 0x8
 870 0027 00       		.byte	0
 871 0028 00       		.byte	0
 872 0029 04       		.uleb128 0x4
 873 002a 16       		.uleb128 0x16
 874 002b 00       		.byte	0
 875 002c 03       		.uleb128 0x3
 876 002d 0E       		.uleb128 0xe
 877 002e 3A       		.uleb128 0x3a
 878 002f 0B       		.uleb128 0xb
 879 0030 3B       		.uleb128 0x3b
 880 0031 05       		.uleb128 0x5
 881 0032 49       		.uleb128 0x49
 882 0033 13       		.uleb128 0x13
 883 0034 00       		.byte	0
 884 0035 00       		.byte	0
 885 0036 05       		.uleb128 0x5
 886 0037 35       		.uleb128 0x35
 887 0038 00       		.byte	0
 888 0039 49       		.uleb128 0x49
 889 003a 13       		.uleb128 0x13
 890 003b 00       		.byte	0
 891 003c 00       		.byte	0
 892 003d 06       		.uleb128 0x6
 893 003e 0F       		.uleb128 0xf
 894 003f 00       		.byte	0
 895 0040 0B       		.uleb128 0xb
 896 0041 0B       		.uleb128 0xb
 897 0042 49       		.uleb128 0x49
 898 0043 13       		.uleb128 0x13
 899 0044 00       		.byte	0
 900 0045 00       		.byte	0
 901 0046 07       		.uleb128 0x7
 902 0047 15       		.uleb128 0x15
 903 0048 00       		.byte	0
 904 0049 27       		.uleb128 0x27
 905 004a 19       		.uleb128 0x19
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 32


 906 004b 00       		.byte	0
 907 004c 00       		.byte	0
 908 004d 08       		.uleb128 0x8
 909 004e 2E       		.uleb128 0x2e
 910 004f 01       		.byte	0x1
 911 0050 3F       		.uleb128 0x3f
 912 0051 19       		.uleb128 0x19
 913 0052 03       		.uleb128 0x3
 914 0053 0E       		.uleb128 0xe
 915 0054 3A       		.uleb128 0x3a
 916 0055 0B       		.uleb128 0xb
 917 0056 3B       		.uleb128 0x3b
 918 0057 0B       		.uleb128 0xb
 919 0058 27       		.uleb128 0x27
 920 0059 19       		.uleb128 0x19
 921 005a 11       		.uleb128 0x11
 922 005b 01       		.uleb128 0x1
 923 005c 12       		.uleb128 0x12
 924 005d 06       		.uleb128 0x6
 925 005e 40       		.uleb128 0x40
 926 005f 18       		.uleb128 0x18
 927 0060 9642     		.uleb128 0x2116
 928 0062 19       		.uleb128 0x19
 929 0063 01       		.uleb128 0x1
 930 0064 13       		.uleb128 0x13
 931 0065 00       		.byte	0
 932 0066 00       		.byte	0
 933 0067 09       		.uleb128 0x9
 934 0068 34       		.uleb128 0x34
 935 0069 00       		.byte	0
 936 006a 03       		.uleb128 0x3
 937 006b 0E       		.uleb128 0xe
 938 006c 3A       		.uleb128 0x3a
 939 006d 0B       		.uleb128 0xb
 940 006e 3B       		.uleb128 0x3b
 941 006f 0B       		.uleb128 0xb
 942 0070 49       		.uleb128 0x49
 943 0071 13       		.uleb128 0x13
 944 0072 02       		.uleb128 0x2
 945 0073 17       		.uleb128 0x17
 946 0074 00       		.byte	0
 947 0075 00       		.byte	0
 948 0076 0A       		.uleb128 0xa
 949 0077 34       		.uleb128 0x34
 950 0078 00       		.byte	0
 951 0079 03       		.uleb128 0x3
 952 007a 0E       		.uleb128 0xe
 953 007b 3A       		.uleb128 0x3a
 954 007c 0B       		.uleb128 0xb
 955 007d 3B       		.uleb128 0x3b
 956 007e 0B       		.uleb128 0xb
 957 007f 49       		.uleb128 0x49
 958 0080 13       		.uleb128 0x13
 959 0081 3F       		.uleb128 0x3f
 960 0082 19       		.uleb128 0x19
 961 0083 3C       		.uleb128 0x3c
 962 0084 19       		.uleb128 0x19
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 33


 963 0085 00       		.byte	0
 964 0086 00       		.byte	0
 965 0087 00       		.byte	0
 966              		.section	.debug_loc,"",%progbits
 967              	.Ldebug_loc0:
 968              	.LLST0:
 969 0000 24010000 		.4byte	.LVL16
 970 0004 36010000 		.4byte	.LVL18
 971 0008 0100     		.2byte	0x1
 972 000a 54       		.byte	0x54
 973 000b 36010000 		.4byte	.LVL18
 974 000f 3C010000 		.4byte	.LVL19
 975 0013 0200     		.2byte	0x2
 976 0015 38       		.byte	0x38
 977 0016 9F       		.byte	0x9f
 978 0017 3C010000 		.4byte	.LVL19
 979 001b 3E010000 		.4byte	.LVL20
 980 001f 0100     		.2byte	0x1
 981 0021 54       		.byte	0x54
 982 0022 40010000 		.4byte	.LVL21
 983 0026 60010000 		.4byte	.LVL23
 984 002a 0100     		.2byte	0x1
 985 002c 54       		.byte	0x54
 986 002d 00000000 		.4byte	0
 987 0031 00000000 		.4byte	0
 988              	.LLST1:
 989 0035 02000000 		.4byte	.LVL0
 990 0039 36000000 		.4byte	.LVL2
 991 003d 0200     		.2byte	0x2
 992 003f 30       		.byte	0x30
 993 0040 9F       		.byte	0x9f
 994 0041 36000000 		.4byte	.LVL2
 995 0045 3A000000 		.4byte	.LVL3
 996 0049 0200     		.2byte	0x2
 997 004b 31       		.byte	0x31
 998 004c 9F       		.byte	0x9f
 999 004d 3A000000 		.4byte	.LVL3
 1000 0051 3C000000 		.4byte	.LVL4
 1001 0055 0200     		.2byte	0x2
 1002 0057 30       		.byte	0x30
 1003 0058 9F       		.byte	0x9f
 1004 0059 3C000000 		.4byte	.LVL4
 1005 005d 4A000000 		.4byte	.LVL5
 1006 0061 0100     		.2byte	0x1
 1007 0063 53       		.byte	0x53
 1008 0064 50000000 		.4byte	.LVL6
 1009 0068 52000000 		.4byte	.LVL7
 1010 006c 0200     		.2byte	0x2
 1011 006e 31       		.byte	0x31
 1012 006f 9F       		.byte	0x9f
 1013 0070 52000000 		.4byte	.LVL7
 1014 0074 74000000 		.4byte	.LVL8
 1015 0078 0100     		.2byte	0x1
 1016 007a 53       		.byte	0x53
 1017 007b 74000000 		.4byte	.LVL8
 1018 007f 76000000 		.4byte	.LVL9
 1019 0083 0200     		.2byte	0x2
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 34


 1020 0085 30       		.byte	0x30
 1021 0086 9F       		.byte	0x9f
 1022 0087 76000000 		.4byte	.LVL9
 1023 008b 8C000000 		.4byte	.LVL10
 1024 008f 0100     		.2byte	0x1
 1025 0091 53       		.byte	0x53
 1026 0092 AC000000 		.4byte	.LVL11
 1027 0096 C0000000 		.4byte	.LVL12
 1028 009a 0100     		.2byte	0x1
 1029 009c 53       		.byte	0x53
 1030 009d CE000000 		.4byte	.LVL13
 1031 00a1 D2000000 		.4byte	.LVL14
 1032 00a5 0200     		.2byte	0x2
 1033 00a7 31       		.byte	0x31
 1034 00a8 9F       		.byte	0x9f
 1035 00a9 D2000000 		.4byte	.LVL14
 1036 00ad 32010000 		.4byte	.LVL17
 1037 00b1 0100     		.2byte	0x1
 1038 00b3 53       		.byte	0x53
 1039 00b4 36010000 		.4byte	.LVL18
 1040 00b8 3C010000 		.4byte	.LVL19
 1041 00bc 0200     		.2byte	0x2
 1042 00be 31       		.byte	0x31
 1043 00bf 9F       		.byte	0x9f
 1044 00c0 3C010000 		.4byte	.LVL19
 1045 00c4 A8010000 		.4byte	.LVL25
 1046 00c8 0100     		.2byte	0x1
 1047 00ca 53       		.byte	0x53
 1048 00cb EE010000 		.4byte	.LVL26
 1049 00cf F2010000 		.4byte	.LVL27
 1050 00d3 0200     		.2byte	0x2
 1051 00d5 31       		.byte	0x31
 1052 00d6 9F       		.byte	0x9f
 1053 00d7 F2010000 		.4byte	.LVL27
 1054 00db 50020000 		.4byte	.LVL28
 1055 00df 0100     		.2byte	0x1
 1056 00e1 53       		.byte	0x53
 1057 00e2 56020000 		.4byte	.LVL29
 1058 00e6 58020000 		.4byte	.LVL30
 1059 00ea 0200     		.2byte	0x2
 1060 00ec 31       		.byte	0x31
 1061 00ed 9F       		.byte	0x9f
 1062 00ee 58020000 		.4byte	.LVL30
 1063 00f2 62020000 		.4byte	.LVL31
 1064 00f6 0100     		.2byte	0x1
 1065 00f8 53       		.byte	0x53
 1066 00f9 AA020000 		.4byte	.LVL32
 1067 00fd AC020000 		.4byte	.LVL33
 1068 0101 0100     		.2byte	0x1
 1069 0103 53       		.byte	0x53
 1070 0104 00000000 		.4byte	0
 1071 0108 00000000 		.4byte	0
 1072              		.section	.debug_aranges,"",%progbits
 1073 0000 1C000000 		.4byte	0x1c
 1074 0004 0200     		.2byte	0x2
 1075 0006 00000000 		.4byte	.Ldebug_info0
 1076 000a 04       		.byte	0x4
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 35


 1077 000b 00       		.byte	0
 1078 000c 0000     		.2byte	0
 1079 000e 0000     		.2byte	0
 1080 0010 00000000 		.4byte	.LFB0
 1081 0014 A0030000 		.4byte	.LFE0-.LFB0
 1082 0018 00000000 		.4byte	0
 1083 001c 00000000 		.4byte	0
 1084              		.section	.debug_ranges,"",%progbits
 1085              	.Ldebug_ranges0:
 1086 0000 00000000 		.4byte	.LFB0
 1087 0004 A0030000 		.4byte	.LFE0
 1088 0008 00000000 		.4byte	0
 1089 000c 00000000 		.4byte	0
 1090              		.section	.debug_line,"",%progbits
 1091              	.Ldebug_line0:
 1092 0000 7C010000 		.section	.debug_str,"MS",%progbits,1
 1092      02007F00 
 1092      00000201 
 1092      FB0E0D00 
 1092      01010101 
 1093              	.LASF15:
 1094 0000 72656733 		.ascii	"reg32\000"
 1094      3200
 1095              	.LASF27:
 1096 0006 4932435F 		.ascii	"I2C_mstrWrBufPtr\000"
 1096      6D737472 
 1096      57724275 
 1096      66507472 
 1096      00
 1097              	.LASF3:
 1098 0017 73686F72 		.ascii	"short unsigned int\000"
 1098      7420756E 
 1098      7369676E 
 1098      65642069 
 1098      6E7400
 1099              	.LASF19:
 1100 002a 656E6454 		.ascii	"endTransfer\000"
 1100      72616E73 
 1100      66657200 
 1101              	.LASF20:
 1102 0036 4932435F 		.ascii	"I2C_customIntrHandler\000"
 1102      63757374 
 1102      6F6D496E 
 1102      74724861 
 1102      6E646C65 
 1103              	.LASF26:
 1104 004c 4932435F 		.ascii	"I2C_mstrRdBufIndex\000"
 1104      6D737472 
 1104      52644275 
 1104      66496E64 
 1104      657800
 1105              	.LASF12:
 1106 005f 666C6F61 		.ascii	"float\000"
 1106      7400
 1107              	.LASF0:
 1108 0065 7369676E 		.ascii	"signed char\000"
 1108      65642063 
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 36


 1108      68617200 
 1109              	.LASF1:
 1110 0071 756E7369 		.ascii	"unsigned char\000"
 1110      676E6564 
 1110      20636861 
 1110      7200
 1111              	.LASF23:
 1112 007f 4932435F 		.ascii	"I2C_mstrControl\000"
 1112      6D737472 
 1112      436F6E74 
 1112      726F6C00 
 1113              	.LASF5:
 1114 008f 6C6F6E67 		.ascii	"long unsigned int\000"
 1114      20756E73 
 1114      69676E65 
 1114      6420696E 
 1114      7400
 1115              	.LASF18:
 1116 00a1 64696666 		.ascii	"diffCount\000"
 1116      436F756E 
 1116      7400
 1117              	.LASF9:
 1118 00ab 75696E74 		.ascii	"uint8\000"
 1118      3800
 1119              	.LASF34:
 1120 00b1 4932435F 		.ascii	"I2C_I2C_ISR\000"
 1120      4932435F 
 1120      49535200 
 1121              	.LASF13:
 1122 00bd 646F7562 		.ascii	"double\000"
 1122      6C6500
 1123              	.LASF10:
 1124 00c4 75696E74 		.ascii	"uint16\000"
 1124      313600
 1125              	.LASF11:
 1126 00cb 75696E74 		.ascii	"uint32\000"
 1126      333200
 1127              	.LASF25:
 1128 00d2 4932435F 		.ascii	"I2C_mstrRdBufSize\000"
 1128      6D737472 
 1128      52644275 
 1128      6653697A 
 1128      6500
 1129              	.LASF8:
 1130 00e4 756E7369 		.ascii	"unsigned int\000"
 1130      676E6564 
 1130      20696E74 
 1130      00
 1131              	.LASF7:
 1132 00f1 6C6F6E67 		.ascii	"long long unsigned int\000"
 1132      206C6F6E 
 1132      6720756E 
 1132      7369676E 
 1132      65642069 
 1133              	.LASF16:
 1134 0108 63796973 		.ascii	"cyisraddress\000"
 1134      72616464 
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 37


 1134      72657373 
 1134      00
 1135              	.LASF33:
 1136 0115 433A5C55 		.ascii	"C:\\Users\\IEUser\\PSoC4_Projects\\Security system\\"
 1136      73657273 
 1136      5C494555 
 1136      7365725C 
 1136      50536F43 
 1137 0144 53656375 		.ascii	"Security_system.cydsn\000"
 1137      72697479 
 1137      5F737973 
 1137      74656D2E 
 1137      63796473 
 1138              	.LASF17:
 1139 015a 73697A65 		.ascii	"sizetype\000"
 1139      74797065 
 1139      00
 1140              	.LASF6:
 1141 0163 6C6F6E67 		.ascii	"long long int\000"
 1141      206C6F6E 
 1141      6720696E 
 1141      7400
 1142              	.LASF14:
 1143 0171 63686172 		.ascii	"char\000"
 1143      00
 1144              	.LASF31:
 1145 0176 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1145      4320342E 
 1145      392E3320 
 1145      32303135 
 1145      30333033 
 1146 01a9 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 1146      20726576 
 1146      6973696F 
 1146      6E203232 
 1146      31323230 
 1147 01dc 67202D66 		.ascii	"g -ffunction-sections -ffat-lto-objects\000"
 1147      66756E63 
 1147      74696F6E 
 1147      2D736563 
 1147      74696F6E 
 1148              	.LASF2:
 1149 0204 73686F72 		.ascii	"short int\000"
 1149      7420696E 
 1149      7400
 1150              	.LASF22:
 1151 020e 4932435F 		.ascii	"I2C_mstrStatus\000"
 1151      6D737472 
 1151      53746174 
 1151      757300
 1152              	.LASF24:
 1153 021d 4932435F 		.ascii	"I2C_mstrRdBufPtr\000"
 1153      6D737472 
 1153      52644275 
 1153      66507472 
 1153      00
 1154              	.LASF30:
ARM GAS  C:\Users\IEUser\AppData\Local\Temp\ccqTowbb.s 			page 38


 1155 022e 4932435F 		.ascii	"I2C_mstrWrBufIndexTmp\000"
 1155      6D737472 
 1155      57724275 
 1155      66496E64 
 1155      6578546D 
 1156              	.LASF4:
 1157 0244 6C6F6E67 		.ascii	"long int\000"
 1157      20696E74 
 1157      00
 1158              	.LASF21:
 1159 024d 4932435F 		.ascii	"I2C_state\000"
 1159      73746174 
 1159      6500
 1160              	.LASF29:
 1161 0257 4932435F 		.ascii	"I2C_mstrWrBufIndex\000"
 1161      6D737472 
 1161      57724275 
 1161      66496E64 
 1161      657800
 1162              	.LASF28:
 1163 026a 4932435F 		.ascii	"I2C_mstrWrBufSize\000"
 1163      6D737472 
 1163      57724275 
 1163      6653697A 
 1163      6500
 1164              	.LASF32:
 1165 027c 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\I2C_I2C_INT.c\000"
 1165      6E657261 
 1165      7465645F 
 1165      536F7572 
 1165      63655C50 
 1166              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
